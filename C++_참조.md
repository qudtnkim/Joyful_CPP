####### *날짜  2022-08-16 12:55*

태그: #개발 #컴퓨터언어 #CPP #참조 #포인터 #메모리관리

### 9. 참조, 포인터, 메모리 관리
---

- [ ] 참조 변수와 참조 자료형을 이해함.
- [ ] 메모리 위치의 주소를 나타내는 포인터를 알아봄.
- [ ] 포인터 자료형과 포인터 변수를 알아본다. 
- [ ] #배열 과 #포인터 의 관계
- [ ] 효율적인 #메모리관리 를 위해 메모리 구성을 알아본다.
- [ ] 프로그램이 활용하는 4개의 메모리 영역을 알아본다.

- 복합자료형 
배열이 하나의 자료형을 여러번  선언하는 개념으로써 복합자료형이라고 했다.

참조와 포인터 역시 복합 자료형에 속한다.

- #참조 는 #객체 를 부르는 다른 이름 ( #참조 는 #CPP 에 처음 추가된 개념이라고 함)

## 참조변수
- **==참조변수는 일반적인 변수와 다르게 메모리 위에 새로운 영역을 잡지 않는다.==**
- 기존에 있던 변수와 바인드해서, 기존에 있던 변수에 새로운 이름을 붙이는 것 뿐임.
> int score = 92; //int 자료형 변수 score를 선언하고 초기화
> int& rScore = score; // int& 자료현의 변수 rScore 를 선언하고 연결

#프로그래밍관례 
> ==일반적으로 참조 변수에 이름을 붙일 때는 원본의 앞글자를 대문자로 바꾸고 ,그앞에 r을 붙여주는 식으로 표현한다.==

## 참조 자료형
- 원본 변수와 참조 변수가 같은 메모리 위치를 가리키므로 값은 같지만, 원본 변수와 참조 변수 자료형은 다르다. 
- 2개의 이름으로 (원본 변수 이름과 참조 변수 이름) 메모리 위에 하나의 위치만 잡는 것임.

|원본 변수 이름|int score|값: 92|int& rScore|참조 변수 이름|
|-----|-----|-----|-----|-----|
- 참조시에 자료형 일치가 되지 않으면 컴파일 오류가 발생한다.
> int num = 100;
> double& rNum = num;  //자료형이 맞지 않아서 컴파일 오류가 발생.

## ==참조관계== 
#constant_relation
참조 변수가 선언되고 어떤 변수와 연결되면, 참조 관계는 #스코프 를 벗어나서 변수가 pop 되기 전까지는 계속 유지됨. **==참조관계는 한 번 정의되면 변경할 수 없음을 의미함.**== 

자료형 변수와 참조형 변수가 연결되어있는 관계를 constant relation이라고 함. "영구적인 관계"로 표현하기로 함.
==참조 관계를 깨려고 하면 컴파일 오류가 발생함==
> //예시
> int score = 92;
> int& rScore = score;
> int num = 80;
> int& rScore = num; //컴파일 오류 발생

## 참조다중성
>int num = 100;
>num& rNum1 =num; // rNum1과 num을 연결
>num& rNum2 =num; // rNum2과 num을 연결
>num& rNum3 =num; // rNum3과 num을 연결

|     |rNum2|      |
|-----|-----|-----|
|num|100|rNum1|
||rNum3||

>100이라는 값이 있는 메모리 위치에 4개의 이름이 붙음.

num, rNum1, rNum2, rNum3 이라는 4개의 이름으로 접근할 수 있음.

# 값 변경
참조 관계가 만들어지면 데이터 변수 또는 참조 변수를 사용해서 원본 값을 변경할 수 있음.
>==원본 변수에 const 한정자가 붙을 경우를 제외함== //변경 불가

# 참조의 활용
==하나의 함수 내부에서 참조 변수를 사용할 일이 없기에, 서로 다른 스코프에서 하나의 변수를 사용해야할 때, 참조를 사용함.==

즉 함수의 커뮤니케이션 (값의 전달)에 참조를 활용한다는 뜻인데 이는 #passbyvalue #passbyreference 이다.

이 때 복사해야하는 변수 나 함수의 크기가 크다면 참조를 고려하여야하는데 이를 #복사비용 을 고려한다고 한다.

==클래스의 복사 생성자를 만드는 경우는?==
객체를 전달해야 하므로 값으로 전달은 복사비용이 많이 들고, 값으로 전달 자체는 복사 생성장를 활용하는 것이므로 ==복사 생성자에서는 값으로 전달을 사용하지 않는다== [[C++_클래스와 생성자]] 복사 생성자에 const 한정자를 붙인 참조를 사용하는 이유.
[[복사생성자]]

### 출처(참고문헌)
- 포르잔 c++ 바이블

### 연결문서
[[객체 지향 프로그래밍]]
[[메모리]]
[[자료형]]
[[복사생성자]]
[[C++_포인터]]

